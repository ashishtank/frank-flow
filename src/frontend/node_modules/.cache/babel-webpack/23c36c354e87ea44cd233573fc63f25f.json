{"ast":null,"code":"/// <reference lib=\"webworker\" />\nimport * as saxes from 'saxes';\nimport { FlowStructure } from '../models/flowStructure.model';\nimport { FlowStructureNode } from '../models/flowStructureNode.model';\nconst MONACO_COLUMN_OFFSET = 1;\nlet parser = new saxes.SaxesParser();\nlet flowStructure;\nlet unclosedPipes = [];\nlet bufferAttributes;\nlet pipeline;\nlet endLine;\naddEventListener('message', ({\n  data\n}) => {\n  if (typeof data === 'string') {\n    flowStructure = new FlowStructure();\n\n    try {\n      parser.write(data).close();\n    } catch (e) {\n      parser = new saxes.SaxesParser();\n    }\n  }\n});\nparser.on('end', () => {\n  const newFlowStructure = new FlowStructure(flowStructure.nodes, flowStructure.firstPipe);\n  newFlowStructure.pipeline = pipeline;\n  postMessage(newFlowStructure);\n});\nparser.on('opentag', tag => {\n  var _a, _b;\n\n  const currentNode = new FlowStructureNode(parser.line, endLine, parser.column + MONACO_COLUMN_OFFSET, tag.name, bufferAttributes);\n  bufferAttributes = {};\n\n  if (currentNode.type.match(/Pipe$/g)) {\n    if (!tag.isSelfClosing) {\n      unclosedPipes.push(currentNode.name);\n    }\n\n    currentNode.forwards = [];\n    flowStructure.nodes.push(currentNode);\n  } else if (currentNode.type === 'Forward') {\n    (_b = (_a = flowStructure.nodes.find(pipe => {\n      return pipe.name === unclosedPipes[unclosedPipes.length - 1];\n    })) === null || _a === void 0 ? void 0 : _a.forwards) === null || _b === void 0 ? void 0 : _b.push(currentNode);\n  } else if (currentNode.type.match(/Listener$/g)) {\n    flowStructure.nodes.push(currentNode);\n  } else if (currentNode.type.match(/Exit$/g)) {\n    flowStructure.nodes.push(currentNode);\n  } else if (currentNode.type === 'Pipeline') {\n    pipeline = currentNode;\n  }\n});\nparser.on('closetag', tag => {\n  endLine = parser.line;\n\n  if (tag.attributes['name'] === unclosedPipes[unclosedPipes.length - 1]) {\n    let closingTag = unclosedPipes.pop();\n    let pipe = flowStructure.nodes.find(pipe => {\n      return pipe.name === closingTag;\n    });\n\n    if (pipe) {\n      pipe.endLine = parser.line;\n    }\n  }\n});\nparser.on('attribute', attribute => {\n  const startColumn = parser.column - (attribute.name + attribute.value).length - 2; // Quote and equals sign\n\n  if (attribute.name === 'firstPipe') {\n    flowStructure.firstPipe = attribute.value;\n  } else {\n    const newAttribute = {\n      value: attribute.value,\n      line: parser.line,\n      endColumn: parser.column + MONACO_COLUMN_OFFSET,\n      startColumn\n    };\n    bufferAttributes = Object.assign(Object.assign({}, bufferAttributes), {\n      [attribute.name]: newAttribute\n    });\n  }\n});","map":null,"metadata":{},"sourceType":"module"}