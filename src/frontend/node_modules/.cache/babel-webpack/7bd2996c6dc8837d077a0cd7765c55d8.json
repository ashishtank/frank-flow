{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ed5 = require(\"xmlchars/xml/1.0/ed5\");\n\nconst ed2 = require(\"xmlchars/xml/1.1/ed2\");\n\nconst NSed3 = require(\"xmlchars/xmlns/1.0/ed3\");\n\nvar isS = ed5.isS;\nvar isChar10 = ed5.isChar;\nvar isNameStartChar = ed5.isNameStartChar;\nvar isNameChar = ed5.isNameChar;\nvar S_LIST = ed5.S_LIST;\nvar NAME_RE = ed5.NAME_RE;\nvar isChar11 = ed2.isChar;\nvar isNCNameStartChar = NSed3.isNCNameStartChar;\nvar isNCNameChar = NSed3.isNCNameChar;\nvar NC_NAME_RE = NSed3.NC_NAME_RE;\nconst XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\nconst XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\nconst rootNS = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  __proto__: null,\n  xml: XML_NAMESPACE,\n  xmlns: XMLNS_NAMESPACE\n};\nconst XML_ENTITIES = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  __proto__: null,\n  amp: \"&\",\n  gt: \">\",\n  lt: \"<\",\n  quot: \"\\\"\",\n  apos: \"'\"\n}; // EOC: end-of-chunk\n\nconst EOC = -1;\nconst NL_LIKE = -2;\nconst S_BEGIN = 0; // Initial state.\n\nconst S_BEGIN_WHITESPACE = 1; // leading whitespace\n\nconst S_DOCTYPE = 2; // <!DOCTYPE\n\nconst S_DOCTYPE_QUOTE = 3; // <!DOCTYPE \"//blah\n\nconst S_DTD = 4; // <!DOCTYPE \"//blah\" [ ...\n\nconst S_DTD_QUOTED = 5; // <!DOCTYPE \"//blah\" [ \"foo\n\nconst S_DTD_OPEN_WAKA = 6;\nconst S_DTD_OPEN_WAKA_BANG = 7;\nconst S_DTD_COMMENT = 8; // <!--\n\nconst S_DTD_COMMENT_ENDING = 9; // <!-- blah -\n\nconst S_DTD_COMMENT_ENDED = 10; // <!-- blah --\n\nconst S_DTD_PI = 11; // <?\n\nconst S_DTD_PI_ENDING = 12; // <?hi \"there\" ?\n\nconst S_TEXT = 13; // general stuff\n\nconst S_ENTITY = 14; // &amp and such\n\nconst S_OPEN_WAKA = 15; // <\n\nconst S_OPEN_WAKA_BANG = 16; // <!...\n\nconst S_COMMENT = 17; // <!--\n\nconst S_COMMENT_ENDING = 18; // <!-- blah -\n\nconst S_COMMENT_ENDED = 19; // <!-- blah --\n\nconst S_CDATA = 20; // <![CDATA[ something\n\nconst S_CDATA_ENDING = 21; // ]\n\nconst S_CDATA_ENDING_2 = 22; // ]]\n\nconst S_PI_FIRST_CHAR = 23; // <?hi, first char\n\nconst S_PI_REST = 24; // <?hi, rest of the name\n\nconst S_PI_BODY = 25; // <?hi there\n\nconst S_PI_ENDING = 26; // <?hi \"there\" ?\n\nconst S_XML_DECL_NAME_START = 27; // <?xml\n\nconst S_XML_DECL_NAME = 28; // <?xml foo\n\nconst S_XML_DECL_EQ = 29; // <?xml foo=\n\nconst S_XML_DECL_VALUE_START = 30; // <?xml foo=\n\nconst S_XML_DECL_VALUE = 31; // <?xml foo=\"bar\"\n\nconst S_XML_DECL_SEPARATOR = 32; // <?xml foo=\"bar\"\n\nconst S_XML_DECL_ENDING = 33; // <?xml ... ?\n\nconst S_OPEN_TAG = 34; // <strong\n\nconst S_OPEN_TAG_SLASH = 35; // <strong /\n\nconst S_ATTRIB = 36; // <a\n\nconst S_ATTRIB_NAME = 37; // <a foo\n\nconst S_ATTRIB_NAME_SAW_WHITE = 38; // <a foo _\n\nconst S_ATTRIB_VALUE = 39; // <a foo=\n\nconst S_ATTRIB_VALUE_QUOTED = 40; // <a foo=\"bar\n\nconst S_ATTRIB_VALUE_CLOSED = 41; // <a foo=\"bar\"\n\nconst S_ATTRIB_VALUE_UNQUOTED = 42; // <a foo=bar\n\nconst S_CLOSE_TAG = 43; // </a\n\nconst S_CLOSE_TAG_SAW_WHITE = 44; // </a   >\n\nconst TAB = 9;\nconst NL = 0xA;\nconst CR = 0xD;\nconst SPACE = 0x20;\nconst BANG = 0x21;\nconst DQUOTE = 0x22;\nconst AMP = 0x26;\nconst SQUOTE = 0x27;\nconst MINUS = 0x2D;\nconst FORWARD_SLASH = 0x2F;\nconst SEMICOLON = 0x3B;\nconst LESS = 0x3C;\nconst EQUAL = 0x3D;\nconst GREATER = 0x3E;\nconst QUESTION = 0x3F;\nconst OPEN_BRACKET = 0x5B;\nconst CLOSE_BRACKET = 0x5D;\nconst NEL = 0x85;\nconst LS = 0x2028; // Line Separator\n\nconst isQuote = c => c === DQUOTE || c === SQUOTE;\n\nconst QUOTES = [DQUOTE, SQUOTE];\nconst DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];\nconst DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];\nconst XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];\nconst ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];\n\nfunction nsPairCheck(parser, prefix, uri) {\n  switch (prefix) {\n    case \"xml\":\n      if (uri !== XML_NAMESPACE) {\n        parser.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);\n      }\n\n      break;\n\n    case \"xmlns\":\n      if (uri !== XMLNS_NAMESPACE) {\n        parser.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);\n      }\n\n      break;\n\n    default:\n  }\n\n  switch (uri) {\n    case XMLNS_NAMESPACE:\n      parser.fail(prefix === \"\" ? `the default namespace may not be set to ${uri}.` : `may not assign a prefix (even \"xmlns\") to the URI \\\n${XMLNS_NAMESPACE}.`);\n      break;\n\n    case XML_NAMESPACE:\n      switch (prefix) {\n        case \"xml\":\n          // Assinging the XML namespace to \"xml\" is fine.\n          break;\n\n        case \"\":\n          parser.fail(`the default namespace may not be set to ${uri}.`);\n          break;\n\n        default:\n          parser.fail(\"may not assign the xml namespace to another prefix.\");\n      }\n\n      break;\n\n    default:\n  }\n}\n\nfunction nsMappingCheck(parser, mapping) {\n  for (const local of Object.keys(mapping)) {\n    nsPairCheck(parser, local, mapping[local]);\n  }\n}\n\nconst isNCName = name => NC_NAME_RE.test(name);\n\nconst isName = name => NAME_RE.test(name);\n\nconst FORBIDDEN_START = 0;\nconst FORBIDDEN_BRACKET = 1;\nconst FORBIDDEN_BRACKET_BRACKET = 2;\n/**\n * The list of supported events.\n */\n\nexports.EVENTS = [\"xmldecl\", \"text\", \"processinginstruction\", \"doctype\", \"comment\", \"opentagstart\", \"attribute\", \"opentag\", \"closetag\", \"cdata\", \"error\", \"end\", \"ready\"];\nconst EVENT_NAME_TO_HANDLER_NAME = {\n  xmldecl: \"xmldeclHandler\",\n  text: \"textHandler\",\n  processinginstruction: \"piHandler\",\n  doctype: \"doctypeHandler\",\n  comment: \"commentHandler\",\n  opentagstart: \"openTagStartHandler\",\n  attribute: \"attributeHandler\",\n  opentag: \"openTagHandler\",\n  closetag: \"closeTagHandler\",\n  cdata: \"cdataHandler\",\n  error: \"errorHandler\",\n  end: \"endHandler\",\n  ready: \"readyHandler\"\n};\n\nclass SaxesParser {\n  /**\n   * @param opt The parser options.\n   */\n  constructor(opt) {\n    this.opt = opt !== null && opt !== void 0 ? opt : {};\n    this.fragmentOpt = !!this.opt.fragment;\n    const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;\n    this.trackPosition = this.opt.position !== false;\n    this.fileName = this.opt.fileName;\n\n    if (xmlnsOpt) {\n      // This is the function we use to perform name checks on PIs and entities.\n      // When namespaces are used, colons are not allowed in PI target names or\n      // entity names. So the check depends on whether namespaces are used. See:\n      //\n      // https://www.w3.org/XML/xml-names-19990114-errata.html\n      // NE08\n      //\n      this.nameStartCheck = isNCNameStartChar;\n      this.nameCheck = isNCNameChar;\n      this.isName = isNCName; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.processAttribs = this.processAttribsNS; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.pushAttrib = this.pushAttribNS; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      this.ns = Object.assign({\n        __proto__: null\n      }, rootNS);\n      const additional = this.opt.additionalNamespaces;\n\n      if (additional != null) {\n        nsMappingCheck(this, additional);\n        Object.assign(this.ns, additional);\n      }\n    } else {\n      this.nameStartCheck = isNameStartChar;\n      this.nameCheck = isNameChar;\n      this.isName = isName; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.processAttribs = this.processAttribsPlain; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n      this.pushAttrib = this.pushAttribPlain;\n    } //\n    // The order of the members in this table needs to correspond to the state\n    // numbers given to the states that correspond to the methods being recorded\n    // here.\n    //\n\n\n    this.stateTable = [\n    /* eslint-disable @typescript-eslint/unbound-method */\n    this.sBegin, this.sBeginWhitespace, this.sDoctype, this.sDoctypeQuote, this.sDTD, this.sDTDQuoted, this.sDTDOpenWaka, this.sDTDOpenWakaBang, this.sDTDComment, this.sDTDCommentEnding, this.sDTDCommentEnded, this.sDTDPI, this.sDTDPIEnding, this.sText, this.sEntity, this.sOpenWaka, this.sOpenWakaBang, this.sComment, this.sCommentEnding, this.sCommentEnded, this.sCData, this.sCDataEnding, this.sCDataEnding2, this.sPIFirstChar, this.sPIRest, this.sPIBody, this.sPIEnding, this.sXMLDeclNameStart, this.sXMLDeclName, this.sXMLDeclEq, this.sXMLDeclValueStart, this.sXMLDeclValue, this.sXMLDeclSeparator, this.sXMLDeclEnding, this.sOpenTag, this.sOpenTagSlash, this.sAttrib, this.sAttribName, this.sAttribNameSawWhite, this.sAttribValue, this.sAttribValueQuoted, this.sAttribValueClosed, this.sAttribValueUnquoted, this.sCloseTag, this.sCloseTagSawWhite];\n\n    this._init();\n  }\n  /**\n   * Indicates whether or not the parser is closed. If ``true``, wait for\n   * the ``ready`` event to write again.\n   */\n\n\n  get closed() {\n    return this._closed;\n  }\n\n  _init() {\n    var _a;\n\n    this.openWakaBang = \"\";\n    this.text = \"\";\n    this.name = \"\";\n    this.piTarget = \"\";\n    this.entity = \"\";\n    this.q = null;\n    this.tags = [];\n    this.tag = null;\n    this.topNS = null;\n    this.chunk = \"\";\n    this.chunkPosition = 0;\n    this.i = 0;\n    this.prevI = 0;\n    this.carriedFromPrevious = undefined;\n    this.forbiddenState = FORBIDDEN_START;\n    this.attribList = []; // The logic is organized so as to minimize the need to check\n    // this.opt.fragment while parsing.\n\n    const {\n      fragmentOpt\n    } = this;\n    this.state = fragmentOpt ? S_TEXT : S_BEGIN; // We want these to be all true if we are dealing with a fragment.\n\n    this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt; // An XML declaration is intially possible only when parsing whole\n    // documents.\n\n    this.xmlDeclPossible = !fragmentOpt;\n    this.xmlDeclExpects = [\"version\"];\n    this.entityReturnState = undefined;\n    let {\n      defaultXMLVersion\n    } = this.opt;\n\n    if (defaultXMLVersion === undefined) {\n      if (this.opt.forceXMLVersion === true) {\n        throw new Error(\"forceXMLVersion set but defaultXMLVersion is not set\");\n      }\n\n      defaultXMLVersion = \"1.0\";\n    }\n\n    this.setXMLVersion(defaultXMLVersion);\n    this.positionAtNewLine = 0;\n    this.doctype = false;\n    this._closed = false;\n    this.xmlDecl = {\n      version: undefined,\n      encoding: undefined,\n      standalone: undefined\n    };\n    this.line = 1;\n    this.column = 0;\n    this.ENTITIES = Object.create(XML_ENTITIES); // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);\n  }\n  /**\n   * The stream position the parser is currently looking at. This field is\n   * zero-based.\n   *\n   * This field is not based on counting Unicode characters but is to be\n   * interpreted as a plain index into a JavaScript string.\n   */\n\n\n  get position() {\n    return this.chunkPosition + this.i;\n  }\n  /**\n   * The column number of the next character to be read by the parser.  *\n   * This field is zero-based. (The first column in a line is 0.)\n   *\n   * This field reports the index at which the next character would be in the\n   * line if the line were represented as a JavaScript string.  Note that this\n   * *can* be different to a count based on the number of *Unicode characters*\n   * due to how JavaScript handles astral plane characters.\n   *\n   * See [[column]] for a number that corresponds to a count of Unicode\n   * characters.\n   */\n\n\n  get columnIndex() {\n    return this.position - this.positionAtNewLine;\n  }\n  /**\n   * Set an event listener on an event. The parser supports one handler per\n   * event type. If you try to set an event handler over an existing handler,\n   * the old handler is silently overwritten.\n   *\n   * @param name The event to listen to.\n   *\n   * @param handler The handler to set.\n   */\n\n\n  on(name, handler) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;\n  }\n  /**\n   * Unset an event handler.\n   *\n   * @parma name The event to stop listening to.\n   */\n\n\n  off(name) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this[EVENT_NAME_TO_HANDLER_NAME[name]] = undefined;\n  }\n  /**\n   * Make an error object. The error object will have a message that contains\n   * the ``fileName`` option passed at the creation of the parser. If position\n   * tracking was turned on, it will also have line and column number\n   * information.\n   *\n   * @param message The message describing the error to report.\n   *\n   * @returns An error object with a properly formatted message.\n   */\n\n\n  makeError(message) {\n    var _a;\n\n    let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : \"\";\n\n    if (this.trackPosition) {\n      if (msg.length > 0) {\n        msg += \":\";\n      }\n\n      msg += `${this.line}:${this.column}`;\n    }\n\n    if (msg.length > 0) {\n      msg += \": \";\n    }\n\n    return new Error(msg + message);\n  }\n  /**\n   * Report a parsing error. This method is made public so that client code may\n   * check for issues that are outside the scope of this project and can report\n   * errors.\n   *\n   * @param message The error to report.\n   *\n   * @returns this\n   */\n\n\n  fail(message) {\n    const err = this.makeError(message);\n    const handler = this.errorHandler;\n\n    if (handler === undefined) {\n      throw err;\n    } else {\n      handler(err);\n    }\n\n    return this;\n  }\n  /**\n   * Write a XML data to the parser.\n   *\n   * @param chunk The XML data to write.\n   *\n   * @returns this\n   */\n\n\n  write(chunk) {\n    if (this.closed) {\n      return this.fail(\"cannot write after close; assign an onready handler.\");\n    }\n\n    let end = false;\n\n    if (chunk === null) {\n      // We cannot return immediately because carriedFromPrevious may need\n      // processing.\n      end = true;\n      chunk = \"\";\n    } else if (typeof chunk === \"object\") {\n      chunk = chunk.toString();\n    } // We checked if performing a pre-decomposition of the string into an array\n    // of single complete characters (``Array.from(chunk)``) would be faster\n    // than the current repeated calls to ``charCodeAt``. As of August 2018, it\n    // isn't. (There may be Node-specific code that would perform faster than\n    // ``Array.from`` but don't want to be dependent on Node.)\n\n\n    if (this.carriedFromPrevious !== undefined) {\n      // The previous chunk had char we must carry over.\n      chunk = `${this.carriedFromPrevious}${chunk}`;\n      this.carriedFromPrevious = undefined;\n    }\n\n    let limit = chunk.length;\n    const lastCode = chunk.charCodeAt(limit - 1);\n\n    if (!end && ( // A trailing CR or surrogate must be carried over to the next\n    // chunk.\n    lastCode === CR || lastCode >= 0xD800 && lastCode <= 0xDBFF)) {\n      // The chunk ends with a character that must be carried over. We cannot\n      // know how to handle it until we get the next chunk or the end of the\n      // stream. So save it for later.\n      this.carriedFromPrevious = chunk[limit - 1];\n      limit--;\n      chunk = chunk.slice(0, limit);\n    }\n\n    const {\n      stateTable\n    } = this;\n    this.chunk = chunk;\n    this.i = 0;\n\n    while (this.i < limit) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      stateTable[this.state].call(this);\n    }\n\n    this.chunkPosition += limit;\n    return end ? this.end() : this;\n  }\n  /**\n   * Close the current stream. Perform final well-formedness checks and reset\n   * the parser tstate.\n   *\n   * @returns this\n   */\n\n\n  close() {\n    return this.write(null);\n  }\n  /**\n   * Get a single code point out of the current chunk. This updates the current\n   * position if we do position tracking.\n   *\n   * This is the algorithm to use for XML 1.0.\n   *\n   * @returns The character read.\n   */\n\n\n  getCode10() {\n    const {\n      chunk,\n      i\n    } = this;\n    this.prevI = i; // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n    // read this.i again, which is a bit faster.\n\n    this.i = i + 1;\n\n    if (i >= chunk.length) {\n      return EOC;\n    } // Using charCodeAt and handling the surrogates ourselves is faster\n    // than using codePointAt.\n\n\n    const code = chunk.charCodeAt(i);\n    this.column++;\n\n    if (code < 0xD800) {\n      if (code >= SPACE || code === TAB) {\n        return code;\n      }\n\n      switch (code) {\n        case NL:\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL;\n\n        case CR:\n          // We may get NaN if we read past the end of the chunk, which is fine.\n          if (chunk.charCodeAt(i + 1) === NL) {\n            // A \\r\\n sequence is converted to \\n so we have to skip over the\n            // next character. We already know it has a size of 1 so ++ is fine\n            // here.\n            this.i = i + 2;\n          } // Otherwise, a \\r is just converted to \\n, so we don't have to skip\n          // ahead.\n          // In either case, \\r becomes \\n.\n\n\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL_LIKE;\n\n        default:\n          // If we get here, then code < SPACE and it is not NL CR or TAB.\n          this.fail(\"disallowed character.\");\n          return code;\n      }\n    }\n\n    if (code > 0xDBFF) {\n      // This is a specialized version of isChar10 that takes into account\n      // that in this context code > 0xDBFF and code <= 0xFFFF. So it does not\n      // test cases that don't need testing.\n      if (!(code >= 0xE000 && code <= 0xFFFD)) {\n        this.fail(\"disallowed character.\");\n      }\n\n      return code;\n    }\n\n    const final = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);\n    this.i = i + 2; // This is a specialized version of isChar10 that takes into account that in\n    // this context necessarily final >= 0x10000.\n\n    if (final > 0x10FFFF) {\n      this.fail(\"disallowed character.\");\n    }\n\n    return final;\n  }\n  /**\n   * Get a single code point out of the current chunk. This updates the current\n   * position if we do position tracking.\n   *\n   * This is the algorithm to use for XML 1.1.\n   *\n   * @returns {number} The character read.\n   */\n\n\n  getCode11() {\n    const {\n      chunk,\n      i\n    } = this;\n    this.prevI = i; // Yes, we do this instead of doing this.i++. Doing it this way, we do not\n    // read this.i again, which is a bit faster.\n\n    this.i = i + 1;\n\n    if (i >= chunk.length) {\n      return EOC;\n    } // Using charCodeAt and handling the surrogates ourselves is faster\n    // than using codePointAt.\n\n\n    const code = chunk.charCodeAt(i);\n    this.column++;\n\n    if (code < 0xD800) {\n      if (code > 0x1F && code < 0x7F || code > 0x9F && code !== LS || code === TAB) {\n        return code;\n      }\n\n      switch (code) {\n        case NL:\n          // 0xA\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL;\n\n        case CR:\n          {\n            // 0xD\n            // We may get NaN if we read past the end of the chunk, which is\n            // fine.\n            const next = chunk.charCodeAt(i + 1);\n\n            if (next === NL || next === NEL) {\n              // A CR NL or CR NEL sequence is converted to NL so we have to skip\n              // over the next character. We already know it has a size of 1.\n              this.i = i + 2;\n            } // Otherwise, a CR is just converted to NL, no skip.\n\n          }\n\n        /* yes, fall through */\n\n        case NEL: // 0x85\n\n        case LS:\n          // Ox2028\n          this.line++;\n          this.column = 0;\n          this.positionAtNewLine = this.position;\n          return NL_LIKE;\n\n        default:\n          this.fail(\"disallowed character.\");\n          return code;\n      }\n    }\n\n    if (code > 0xDBFF) {\n      // This is a specialized version of isCharAndNotRestricted that takes into\n      // account that in this context code > 0xDBFF and code <= 0xFFFF. So it\n      // does not test cases that don't need testing.\n      if (!(code >= 0xE000 && code <= 0xFFFD)) {\n        this.fail(\"disallowed character.\");\n      }\n\n      return code;\n    }\n\n    const final = 0x10000 + (code - 0xD800) * 0x400 + (chunk.charCodeAt(i + 1) - 0xDC00);\n    this.i = i + 2; // This is a specialized version of isCharAndNotRestricted that takes into\n    // account that in this context necessarily final >= 0x10000.\n\n    if (final > 0x10FFFF) {\n      this.fail(\"disallowed character.\");\n    }\n\n    return final;\n  }\n  /**\n   * Like ``getCode`` but with the return value normalized so that ``NL`` is\n   * returned for ``NL_LIKE``.\n   */\n\n\n  getCodeNorm() {\n    const c = this.getCode();\n    return c === NL_LIKE ? NL : c;\n  }\n\n  unget() {\n    this.i = this.prevI;\n    this.column--;\n  }\n  /**\n   * Capture characters into a buffer until encountering one of a set of\n   * characters.\n   *\n   * @param chars An array of codepoints. Encountering a character in the array\n   * ends the capture. (``chars`` may safely contain ``NL``.)\n   *\n   * @return The character code that made the capture end, or ``EOC`` if we hit\n   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n   * instead.\n   */\n\n\n  captureTo(chars) {\n    let {\n      i: start\n    } = this;\n    const {\n      chunk\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      const c = this.getCode();\n      const isNLLike = c === NL_LIKE;\n      const final = isNLLike ? NL : c;\n\n      if (final === EOC || chars.includes(final)) {\n        this.text += chunk.slice(start, this.prevI);\n        return final;\n      }\n\n      if (isNLLike) {\n        this.text += `${chunk.slice(start, this.prevI)}\\n`;\n        start = this.i;\n      }\n    }\n  }\n  /**\n   * Capture characters into a buffer until encountering a character.\n   *\n   * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT\n   * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.\n   *\n   * @return ``true`` if we ran into the character. Otherwise, we ran into the\n   * end of the current chunk.\n   */\n\n\n  captureToChar(char) {\n    let {\n      i: start\n    } = this;\n    const {\n      chunk\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      let c = this.getCode();\n\n      switch (c) {\n        case NL_LIKE:\n          this.text += `${chunk.slice(start, this.prevI)}\\n`;\n          start = this.i;\n          c = NL;\n          break;\n\n        case EOC:\n          this.text += chunk.slice(start);\n          return false;\n\n        default:\n      }\n\n      if (c === char) {\n        this.text += chunk.slice(start, this.prevI);\n        return true;\n      }\n    }\n  }\n  /**\n   * Capture characters that satisfy ``isNameChar`` into the ``name`` field of\n   * this parser.\n   *\n   * @return The character code that made the test fail, or ``EOC`` if we hit\n   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n   * instead.\n   */\n\n\n  captureNameChars() {\n    const {\n      chunk,\n      i: start\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      const c = this.getCode();\n\n      if (c === EOC) {\n        this.name += chunk.slice(start);\n        return EOC;\n      } // NL is not a name char so we don't have to test specifically for it.\n\n\n      if (!isNameChar(c)) {\n        this.name += chunk.slice(start, this.prevI);\n        return c === NL_LIKE ? NL : c;\n      }\n    }\n  }\n  /**\n   * Skip white spaces.\n   *\n   * @return The character that ended the skip, or ``EOC`` if we hit\n   * the end of the chunk. The return value cannot be NL_LIKE: NL is returned\n   * instead.\n   */\n\n\n  skipSpaces() {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const c = this.getCodeNorm();\n\n      if (c === EOC || !isS(c)) {\n        return c;\n      }\n    }\n  }\n\n  setXMLVersion(version) {\n    this.currentXMLVersion = version;\n    /*  eslint-disable @typescript-eslint/unbound-method */\n\n    if (version === \"1.0\") {\n      this.isChar = isChar10;\n      this.getCode = this.getCode10;\n    } else {\n      this.isChar = isChar11;\n      this.getCode = this.getCode11;\n    }\n    /* eslint-enable @typescript-eslint/unbound-method */\n\n  } // STATE ENGINE METHODS\n  // This needs to be a state separate from S_BEGIN_WHITESPACE because we want\n  // to be sure never to come back to this state later.\n\n\n  sBegin() {\n    // We are essentially peeking at the first character of the chunk. Since\n    // S_BEGIN can be in effect only when we start working on the first chunk,\n    // the index at which we must look is necessarily 0. Note also that the\n    // following test does not depend on decoding surrogates.\n    // If the initial character is 0xFEFF, ignore it.\n    if (this.chunk.charCodeAt(0) === 0xFEFF) {\n      this.i++;\n      this.column++;\n    }\n\n    this.state = S_BEGIN_WHITESPACE;\n  }\n\n  sBeginWhitespace() {\n    // We need to know whether we've encountered spaces or not because as soon\n    // as we run into a space, an XML declaration is no longer possible. Rather\n    // than slow down skipSpaces even in places where we don't care whether it\n    // skipped anything or not, we check whether prevI is equal to the value of\n    // i from before we skip spaces.\n    const iBefore = this.i;\n    const c = this.skipSpaces();\n\n    if (this.prevI !== iBefore) {\n      this.xmlDeclPossible = false;\n    }\n\n    switch (c) {\n      case LESS:\n        this.state = S_OPEN_WAKA; // We could naively call closeText but in this state, it is not normal\n        // to have text be filled with any data.\n\n        if (this.text.length !== 0) {\n          throw new Error(\"no-empty text at start\");\n        }\n\n        break;\n\n      case EOC:\n        break;\n\n      default:\n        this.unget();\n        this.state = S_TEXT;\n        this.xmlDeclPossible = false;\n    }\n  }\n\n  sDoctype() {\n    var _a;\n\n    const c = this.captureTo(DOCTYPE_TERMINATOR);\n\n    switch (c) {\n      case GREATER:\n        {\n          // eslint-disable-next-line no-unused-expressions\n          (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n          this.text = \"\";\n          this.state = S_TEXT;\n          this.doctype = true; // just remember that we saw it.\n\n          break;\n        }\n\n      case EOC:\n        break;\n\n      default:\n        this.text += String.fromCodePoint(c);\n\n        if (c === OPEN_BRACKET) {\n          this.state = S_DTD;\n        } else if (isQuote(c)) {\n          this.state = S_DOCTYPE_QUOTE;\n          this.q = c;\n        }\n\n    }\n  }\n\n  sDoctypeQuote() {\n    const q = this.q;\n\n    if (this.captureToChar(q)) {\n      this.text += String.fromCodePoint(q);\n      this.q = null;\n      this.state = S_DOCTYPE;\n    }\n  }\n\n  sDTD() {\n    const c = this.captureTo(DTD_TERMINATOR);\n\n    if (c === EOC) {\n      return;\n    }\n\n    this.text += String.fromCodePoint(c);\n\n    if (c === CLOSE_BRACKET) {\n      this.state = S_DOCTYPE;\n    } else if (c === LESS) {\n      this.state = S_DTD_OPEN_WAKA;\n    } else if (isQuote(c)) {\n      this.state = S_DTD_QUOTED;\n      this.q = c;\n    }\n  }\n\n  sDTDQuoted() {\n    const q = this.q;\n\n    if (this.captureToChar(q)) {\n      this.text += String.fromCodePoint(q);\n      this.state = S_DTD;\n      this.q = null;\n    }\n  }\n\n  sDTDOpenWaka() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n\n    switch (c) {\n      case BANG:\n        this.state = S_DTD_OPEN_WAKA_BANG;\n        this.openWakaBang = \"\";\n        break;\n\n      case QUESTION:\n        this.state = S_DTD_PI;\n        break;\n\n      default:\n        this.state = S_DTD;\n    }\n  }\n\n  sDTDOpenWakaBang() {\n    const char = String.fromCodePoint(this.getCodeNorm());\n    const owb = this.openWakaBang += char;\n    this.text += char;\n\n    if (owb !== \"-\") {\n      this.state = owb === \"--\" ? S_DTD_COMMENT : S_DTD;\n      this.openWakaBang = \"\";\n    }\n  }\n\n  sDTDComment() {\n    if (this.captureToChar(MINUS)) {\n      this.text += \"-\";\n      this.state = S_DTD_COMMENT_ENDING;\n    }\n  }\n\n  sDTDCommentEnding() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n    this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;\n  }\n\n  sDTDCommentEnded() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n\n    if (c === GREATER) {\n      this.state = S_DTD;\n    } else {\n      this.fail(\"malformed comment.\"); // <!-- blah -- bloo --> will be recorded as\n      // a comment of \" blah -- bloo \"\n\n      this.state = S_DTD_COMMENT;\n    }\n  }\n\n  sDTDPI() {\n    if (this.captureToChar(QUESTION)) {\n      this.text += \"?\";\n      this.state = S_DTD_PI_ENDING;\n    }\n  }\n\n  sDTDPIEnding() {\n    const c = this.getCodeNorm();\n    this.text += String.fromCodePoint(c);\n\n    if (c === GREATER) {\n      this.state = S_DTD;\n    }\n  }\n\n  sText() {\n    //\n    // We did try a version of saxes where the S_TEXT state was split in two\n    // states: one for text inside the root element, and one for text\n    // outside. This was avoiding having to test this.tags.length to decide\n    // what implementation to actually use.\n    //\n    // Peformance testing on gigabyte-size files did not show any advantage to\n    // using the two states solution instead of the current one. Conversely, it\n    // made the code a bit more complicated elsewhere. For instance, a comment\n    // can appear before the root element so when a comment ended it was\n    // necessary to determine whether to return to the S_TEXT state or to the\n    // new text-outside-root state.\n    //\n    if (this.tags.length !== 0) {\n      this.handleTextInRoot();\n    } else {\n      this.handleTextOutsideRoot();\n    }\n  }\n\n  sEntity() {\n    // This is essentially a specialized version of captureToChar(SEMICOLON...)\n    let {\n      i: start\n    } = this;\n    const {\n      chunk\n    } = this; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n    loop: // eslint-disable-next-line no-constant-condition\n    while (true) {\n      switch (this.getCode()) {\n        case NL_LIKE:\n          this.entity += `${chunk.slice(start, this.prevI)}\\n`;\n          start = this.i;\n          break;\n\n        case SEMICOLON:\n          {\n            const {\n              entityReturnState\n            } = this;\n            const entity = this.entity + chunk.slice(start, this.prevI);\n            this.state = entityReturnState;\n            let parsed;\n\n            if (entity === \"\") {\n              this.fail(\"empty entity name.\");\n              parsed = \"&;\";\n            } else {\n              parsed = this.parseEntity(entity);\n              this.entity = \"\";\n            }\n\n            if (entityReturnState !== S_TEXT || this.textHandler !== undefined) {\n              this.text += parsed;\n            } // eslint-disable-next-line no-labels\n\n\n            break loop;\n          }\n\n        case EOC:\n          this.entity += chunk.slice(start); // eslint-disable-next-line no-labels\n\n          break loop;\n\n        default:\n      }\n    }\n  }\n\n  sOpenWaka() {\n    // Reminder: a state handler is called with at least one character\n    // available in the current chunk. So the first call to get code inside of\n    // a state handler cannot return ``EOC``. That's why we don't test\n    // for it.\n    const c = this.getCode(); // either a /, ?, !, or text is coming next.\n\n    if (isNameStartChar(c)) {\n      this.state = S_OPEN_TAG;\n      this.unget();\n      this.xmlDeclPossible = false;\n    } else {\n      switch (c) {\n        case FORWARD_SLASH:\n          this.state = S_CLOSE_TAG;\n          this.xmlDeclPossible = false;\n          break;\n\n        case BANG:\n          this.state = S_OPEN_WAKA_BANG;\n          this.openWakaBang = \"\";\n          this.xmlDeclPossible = false;\n          break;\n\n        case QUESTION:\n          this.state = S_PI_FIRST_CHAR;\n          break;\n\n        default:\n          this.fail(\"disallowed character in tag name\");\n          this.state = S_TEXT;\n          this.xmlDeclPossible = false;\n      }\n    }\n  }\n\n  sOpenWakaBang() {\n    this.openWakaBang += String.fromCodePoint(this.getCodeNorm());\n\n    switch (this.openWakaBang) {\n      case \"[CDATA[\":\n        if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n          this.fail(\"text data outside of root node.\");\n          this.reportedTextBeforeRoot = true;\n        }\n\n        if (this.closedRoot && !this.reportedTextAfterRoot) {\n          this.fail(\"text data outside of root node.\");\n          this.reportedTextAfterRoot = true;\n        }\n\n        this.state = S_CDATA;\n        this.openWakaBang = \"\";\n        break;\n\n      case \"--\":\n        this.state = S_COMMENT;\n        this.openWakaBang = \"\";\n        break;\n\n      case \"DOCTYPE\":\n        this.state = S_DOCTYPE;\n\n        if (this.doctype || this.sawRoot) {\n          this.fail(\"inappropriately located doctype declaration.\");\n        }\n\n        this.openWakaBang = \"\";\n        break;\n\n      default:\n        // 7 happens to be the maximum length of the string that can possibly\n        // match one of the cases above.\n        if (this.openWakaBang.length >= 7) {\n          this.fail(\"incorrect syntax.\");\n        }\n\n    }\n  }\n\n  sComment() {\n    if (this.captureToChar(MINUS)) {\n      this.state = S_COMMENT_ENDING;\n    }\n  }\n\n  sCommentEnding() {\n    var _a;\n\n    const c = this.getCodeNorm();\n\n    if (c === MINUS) {\n      this.state = S_COMMENT_ENDED; // eslint-disable-next-line no-unused-expressions\n\n      (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n      this.text = \"\";\n    } else {\n      this.text += `-${String.fromCodePoint(c)}`;\n      this.state = S_COMMENT;\n    }\n  }\n\n  sCommentEnded() {\n    const c = this.getCodeNorm();\n\n    if (c !== GREATER) {\n      this.fail(\"malformed comment.\"); // <!-- blah -- bloo --> will be recorded as\n      // a comment of \" blah -- bloo \"\n\n      this.text += `--${String.fromCodePoint(c)}`;\n      this.state = S_COMMENT;\n    } else {\n      this.state = S_TEXT;\n    }\n  }\n\n  sCData() {\n    if (this.captureToChar(CLOSE_BRACKET)) {\n      this.state = S_CDATA_ENDING;\n    }\n  }\n\n  sCDataEnding() {\n    const c = this.getCodeNorm();\n\n    if (c === CLOSE_BRACKET) {\n      this.state = S_CDATA_ENDING_2;\n    } else {\n      this.text += `]${String.fromCodePoint(c)}`;\n      this.state = S_CDATA;\n    }\n  }\n\n  sCDataEnding2() {\n    var _a;\n\n    const c = this.getCodeNorm();\n\n    switch (c) {\n      case GREATER:\n        {\n          // eslint-disable-next-line no-unused-expressions\n          (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);\n          this.text = \"\";\n          this.state = S_TEXT;\n          break;\n        }\n\n      case CLOSE_BRACKET:\n        this.text += \"]\";\n        break;\n\n      default:\n        this.text += `]]${String.fromCodePoint(c)}`;\n        this.state = S_CDATA;\n    }\n  } // We need this separate state to check the first character fo the pi target\n  // with this.nameStartCheck which allows less characters than this.nameCheck.\n\n\n  sPIFirstChar() {\n    const c = this.getCodeNorm(); // This is first because in the case where the file is well-formed this is\n    // the branch taken. We optimize for well-formedness.\n\n    if (this.nameStartCheck(c)) {\n      this.piTarget += String.fromCodePoint(c);\n      this.state = S_PI_REST;\n    } else if (c === QUESTION || isS(c)) {\n      this.fail(\"processing instruction without a target.\");\n      this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;\n    } else {\n      this.fail(\"disallowed character in processing instruction name.\");\n      this.piTarget += String.fromCodePoint(c);\n      this.state = S_PI_REST;\n    }\n  }\n\n  sPIRest() {\n    // Capture characters into a piTarget while ``this.nameCheck`` run on the\n    // character read returns true.\n    const {\n      chunk,\n      i: start\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      const c = this.getCodeNorm();\n\n      if (c === EOC) {\n        this.piTarget += chunk.slice(start);\n        return;\n      } // NL cannot satisfy this.nameCheck so we don't have to test specifically\n      // for it.\n\n\n      if (!this.nameCheck(c)) {\n        this.piTarget += chunk.slice(start, this.prevI);\n        const isQuestion = c === QUESTION;\n\n        if (isQuestion || isS(c)) {\n          if (this.piTarget === \"xml\") {\n            if (!this.xmlDeclPossible) {\n              this.fail(\"an XML declaration must be at the start of the document.\");\n            }\n\n            this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;\n          } else {\n            this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;\n          }\n        } else {\n          this.fail(\"disallowed character in processing instruction name.\");\n          this.piTarget += String.fromCodePoint(c);\n        }\n\n        break;\n      }\n    }\n  }\n\n  sPIBody() {\n    if (this.text.length === 0) {\n      const c = this.getCodeNorm();\n\n      if (c === QUESTION) {\n        this.state = S_PI_ENDING;\n      } else if (!isS(c)) {\n        this.text = String.fromCodePoint(c);\n      }\n    } // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n    else if (this.captureToChar(QUESTION)) {\n        this.state = S_PI_ENDING;\n      }\n  }\n\n  sPIEnding() {\n    var _a;\n\n    const c = this.getCodeNorm();\n\n    if (c === GREATER) {\n      const {\n        piTarget\n      } = this;\n\n      if (piTarget.toLowerCase() === \"xml\") {\n        this.fail(\"the XML declaration must appear at the start of the document.\");\n      } // eslint-disable-next-line no-unused-expressions\n\n\n      (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {\n        target: piTarget,\n        body: this.text\n      });\n      this.piTarget = this.text = \"\";\n      this.state = S_TEXT;\n    } else if (c === QUESTION) {\n      // We ran into ?? as part of a processing instruction. We initially took\n      // the first ? as a sign that the PI was ending, but it is not. So we have\n      // to add it to the body but we take the new ? as a sign that the PI is\n      // ending.\n      this.text += \"?\";\n    } else {\n      this.text += `?${String.fromCodePoint(c)}`;\n      this.state = S_PI_BODY;\n    }\n\n    this.xmlDeclPossible = false;\n  }\n\n  sXMLDeclNameStart() {\n    const c = this.skipSpaces(); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      // It is valid to go to S_XML_DECL_ENDING from this state.\n      this.state = S_XML_DECL_ENDING;\n      return;\n    }\n\n    if (c !== EOC) {\n      this.state = S_XML_DECL_NAME;\n      this.name = String.fromCodePoint(c);\n    }\n  }\n\n  sXMLDeclName() {\n    const c = this.captureTo(XML_DECL_NAME_TERMINATOR); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.name += this.text;\n      this.text = \"\";\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n\n    if (!(isS(c) || c === EQUAL)) {\n      return;\n    }\n\n    this.name += this.text;\n    this.text = \"\";\n\n    if (!this.xmlDeclExpects.includes(this.name)) {\n      switch (this.name.length) {\n        case 0:\n          this.fail(\"did not expect any more name/value pairs.\");\n          break;\n\n        case 1:\n          this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);\n          break;\n\n        default:\n          this.fail(`expected one of ${this.xmlDeclExpects.join(\", \")}`);\n      }\n    }\n\n    this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;\n  }\n\n  sXMLDeclEq() {\n    const c = this.getCodeNorm(); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n\n    if (isS(c)) {\n      return;\n    }\n\n    if (c !== EQUAL) {\n      this.fail(\"value required.\");\n    }\n\n    this.state = S_XML_DECL_VALUE_START;\n  }\n\n  sXMLDeclValueStart() {\n    const c = this.getCodeNorm(); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n\n    if (isS(c)) {\n      return;\n    }\n\n    if (!isQuote(c)) {\n      this.fail(\"value must be quoted.\");\n      this.q = SPACE;\n    } else {\n      this.q = c;\n    }\n\n    this.state = S_XML_DECL_VALUE;\n  }\n\n  sXMLDeclValue() {\n    const c = this.captureTo([this.q, QUESTION]); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      this.state = S_XML_DECL_ENDING;\n      this.text = \"\";\n      this.fail(\"XML declaration is incomplete.\");\n      return;\n    }\n\n    if (c === EOC) {\n      return;\n    }\n\n    const value = this.text;\n    this.text = \"\";\n\n    switch (this.name) {\n      case \"version\":\n        {\n          this.xmlDeclExpects = [\"encoding\", \"standalone\"];\n          const version = value;\n          this.xmlDecl.version = version; // This is the test specified by XML 1.0 but it is fine for XML 1.1.\n\n          if (!/^1\\.[0-9]+$/.test(version)) {\n            this.fail(\"version number must match /^1\\\\.[0-9]+$/.\");\n          } // When forceXMLVersion is set, the XML declaration is ignored.\n          else if (!this.opt.forceXMLVersion) {\n              this.setXMLVersion(version);\n            }\n\n          break;\n        }\n\n      case \"encoding\":\n        if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {\n          this.fail(\"encoding value must match \\\n/^[A-Za-z0-9][A-Za-z0-9._-]*$/.\");\n        }\n\n        this.xmlDeclExpects = [\"standalone\"];\n        this.xmlDecl.encoding = value;\n        break;\n\n      case \"standalone\":\n        if (value !== \"yes\" && value !== \"no\") {\n          this.fail(\"standalone value must match \\\"yes\\\" or \\\"no\\\".\");\n        }\n\n        this.xmlDeclExpects = [];\n        this.xmlDecl.standalone = value;\n        break;\n\n      default: // We don't need to raise an error here since we've already raised one\n      // when checking what name was expected.\n\n    }\n\n    this.name = \"\";\n    this.state = S_XML_DECL_SEPARATOR;\n  }\n\n  sXMLDeclSeparator() {\n    const c = this.getCodeNorm(); // The question mark character is not valid inside any of the XML\n    // declaration name/value pairs.\n\n    if (c === QUESTION) {\n      // It is valid to go to S_XML_DECL_ENDING from this state.\n      this.state = S_XML_DECL_ENDING;\n      return;\n    }\n\n    if (!isS(c)) {\n      this.fail(\"whitespace required.\");\n      this.unget();\n    }\n\n    this.state = S_XML_DECL_NAME_START;\n  }\n\n  sXMLDeclEnding() {\n    var _a;\n\n    const c = this.getCodeNorm();\n\n    if (c === GREATER) {\n      if (this.piTarget !== \"xml\") {\n        this.fail(\"processing instructions are not allowed before root.\");\n      } else if (this.name !== \"version\" && this.xmlDeclExpects.includes(\"version\")) {\n        this.fail(\"XML declaration must contain a version.\");\n      } // eslint-disable-next-line no-unused-expressions\n\n\n      (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);\n      this.name = \"\";\n      this.piTarget = this.text = \"\";\n      this.state = S_TEXT;\n    } else {\n      // We got here because the previous character was a ?, but the question\n      // mark character is not valid inside any of the XML declaration\n      // name/value pairs.\n      this.fail(\"The character ? is disallowed anywhere in XML declarations.\");\n    }\n\n    this.xmlDeclPossible = false;\n  }\n\n  sOpenTag() {\n    var _a;\n\n    const c = this.captureNameChars();\n\n    if (c === EOC) {\n      return;\n    }\n\n    const tag = this.tag = {\n      name: this.name,\n      attributes: Object.create(null)\n    };\n    this.name = \"\";\n\n    if (this.xmlnsOpt) {\n      this.topNS = tag.ns = Object.create(null);\n    } // eslint-disable-next-line no-unused-expressions\n\n\n    (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n    this.sawRoot = true;\n\n    if (!this.fragmentOpt && this.closedRoot) {\n      this.fail(\"documents may contain only one root.\");\n    }\n\n    switch (c) {\n      case GREATER:\n        this.openTag();\n        break;\n\n      case FORWARD_SLASH:\n        this.state = S_OPEN_TAG_SLASH;\n        break;\n\n      default:\n        if (!isS(c)) {\n          this.fail(\"disallowed character in tag name.\");\n        }\n\n        this.state = S_ATTRIB;\n    }\n  }\n\n  sOpenTagSlash() {\n    if (this.getCode() === GREATER) {\n      this.openSelfClosingTag();\n    } else {\n      this.fail(\"forward-slash in opening tag not followed by >.\");\n      this.state = S_ATTRIB;\n    }\n  }\n\n  sAttrib() {\n    const c = this.skipSpaces();\n\n    if (c === EOC) {\n      return;\n    }\n\n    if (isNameStartChar(c)) {\n      this.unget();\n      this.state = S_ATTRIB_NAME;\n    } else if (c === GREATER) {\n      this.openTag();\n    } else if (c === FORWARD_SLASH) {\n      this.state = S_OPEN_TAG_SLASH;\n    } else {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n\n  sAttribName() {\n    const c = this.captureNameChars();\n\n    if (c === EQUAL) {\n      this.state = S_ATTRIB_VALUE;\n    } else if (isS(c)) {\n      this.state = S_ATTRIB_NAME_SAW_WHITE;\n    } else if (c === GREATER) {\n      this.fail(\"attribute without value.\");\n      this.pushAttrib(this.name, this.name);\n      this.name = this.text = \"\";\n      this.openTag();\n    } else if (c !== EOC) {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n\n  sAttribNameSawWhite() {\n    const c = this.skipSpaces();\n\n    switch (c) {\n      case EOC:\n        return;\n\n      case EQUAL:\n        this.state = S_ATTRIB_VALUE;\n        break;\n\n      default:\n        this.fail(\"attribute without value.\"); // Should we do this???\n        // this.tag.attributes[this.name] = \"\";\n\n        this.text = \"\";\n        this.name = \"\";\n\n        if (c === GREATER) {\n          this.openTag();\n        } else if (isNameStartChar(c)) {\n          this.unget();\n          this.state = S_ATTRIB_NAME;\n        } else {\n          this.fail(\"disallowed character in attribute name.\");\n          this.state = S_ATTRIB;\n        }\n\n    }\n  }\n\n  sAttribValue() {\n    const c = this.getCodeNorm();\n\n    if (isQuote(c)) {\n      this.q = c;\n      this.state = S_ATTRIB_VALUE_QUOTED;\n    } else if (!isS(c)) {\n      this.fail(\"unquoted attribute value.\");\n      this.state = S_ATTRIB_VALUE_UNQUOTED;\n      this.unget();\n    }\n  }\n\n  sAttribValueQuoted() {\n    // We deliberately do not use captureTo here. The specialized code we use\n    // here is faster than using captureTo.\n    const {\n      q,\n      chunk\n    } = this;\n    let {\n      i: start\n    } = this; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      switch (this.getCode()) {\n        case q:\n          this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));\n          this.name = this.text = \"\";\n          this.q = null;\n          this.state = S_ATTRIB_VALUE_CLOSED;\n          return;\n\n        case AMP:\n          this.text += chunk.slice(start, this.prevI);\n          this.state = S_ENTITY;\n          this.entityReturnState = S_ATTRIB_VALUE_QUOTED;\n          return;\n\n        case NL:\n        case NL_LIKE:\n        case TAB:\n          this.text += `${chunk.slice(start, this.prevI)} `;\n          start = this.i;\n          break;\n\n        case LESS:\n          this.text += chunk.slice(start, this.prevI);\n          this.fail(\"disallowed character.\");\n          return;\n\n        case EOC:\n          this.text += chunk.slice(start);\n          return;\n\n        default:\n      }\n    }\n  }\n\n  sAttribValueClosed() {\n    const c = this.getCodeNorm();\n\n    if (isS(c)) {\n      this.state = S_ATTRIB;\n    } else if (c === GREATER) {\n      this.openTag();\n    } else if (c === FORWARD_SLASH) {\n      this.state = S_OPEN_TAG_SLASH;\n    } else if (isNameStartChar(c)) {\n      this.fail(\"no whitespace between attributes.\");\n      this.unget();\n      this.state = S_ATTRIB_NAME;\n    } else {\n      this.fail(\"disallowed character in attribute name.\");\n    }\n  }\n\n  sAttribValueUnquoted() {\n    // We don't do anything regarding EOL or space handling for unquoted\n    // attributes. We already have failed by the time we get here, and the\n    // contract that saxes upholds states that upon failure, it is not safe to\n    // rely on the data passed to event handlers (other than\n    // ``onerror``). Passing \"bad\" data is not a problem.\n    const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);\n\n    switch (c) {\n      case AMP:\n        this.state = S_ENTITY;\n        this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;\n        break;\n\n      case LESS:\n        this.fail(\"disallowed character.\");\n        break;\n\n      case EOC:\n        break;\n\n      default:\n        if (this.text.includes(\"]]>\")) {\n          this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n        }\n\n        this.pushAttrib(this.name, this.text);\n        this.name = this.text = \"\";\n\n        if (c === GREATER) {\n          this.openTag();\n        } else {\n          this.state = S_ATTRIB;\n        }\n\n    }\n  }\n\n  sCloseTag() {\n    const c = this.captureNameChars();\n\n    if (c === GREATER) {\n      this.closeTag();\n    } else if (isS(c)) {\n      this.state = S_CLOSE_TAG_SAW_WHITE;\n    } else if (c !== EOC) {\n      this.fail(\"disallowed character in closing tag.\");\n    }\n  }\n\n  sCloseTagSawWhite() {\n    switch (this.skipSpaces()) {\n      case GREATER:\n        this.closeTag();\n        break;\n\n      case EOC:\n        break;\n\n      default:\n        this.fail(\"disallowed character in closing tag.\");\n    }\n  } // END OF STATE ENGINE METHODS\n\n\n  handleTextInRoot() {\n    // This is essentially a specialized version of captureTo which is optimized\n    // for performing the ]]> check. A previous version of this code, checked\n    // ``this.text`` for the presence of ]]>. It simplified the code but was\n    // very costly when character data contained a lot of entities to be parsed.\n    //\n    // Since we are using a specialized loop, we also keep track of the presence\n    // of ]]> in text data. The sequence ]]> is forbidden to appear as-is.\n    //\n    let {\n      i: start,\n      forbiddenState\n    } = this;\n    const {\n      chunk,\n      textHandler: handler\n    } = this; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n    scanLoop: // eslint-disable-next-line no-constant-condition\n    while (true) {\n      switch (this.getCode()) {\n        case LESS:\n          {\n            this.state = S_OPEN_WAKA;\n\n            if (handler !== undefined) {\n              const {\n                text\n              } = this;\n              const slice = chunk.slice(start, this.prevI);\n\n              if (text.length !== 0) {\n                handler(text + slice);\n                this.text = \"\";\n              } else if (slice.length !== 0) {\n                handler(slice);\n              }\n            }\n\n            forbiddenState = FORBIDDEN_START; // eslint-disable-next-line no-labels\n\n            break scanLoop;\n          }\n\n        case AMP:\n          this.state = S_ENTITY;\n          this.entityReturnState = S_TEXT;\n\n          if (handler !== undefined) {\n            this.text += chunk.slice(start, this.prevI);\n          }\n\n          forbiddenState = FORBIDDEN_START; // eslint-disable-next-line no-labels\n\n          break scanLoop;\n\n        case CLOSE_BRACKET:\n          switch (forbiddenState) {\n            case FORBIDDEN_START:\n              forbiddenState = FORBIDDEN_BRACKET;\n              break;\n\n            case FORBIDDEN_BRACKET:\n              forbiddenState = FORBIDDEN_BRACKET_BRACKET;\n              break;\n\n            case FORBIDDEN_BRACKET_BRACKET:\n              break;\n\n            default:\n              throw new Error(\"impossible state\");\n          }\n\n          break;\n\n        case GREATER:\n          if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {\n            this.fail(\"the string \\\"]]>\\\" is disallowed in char data.\");\n          }\n\n          forbiddenState = FORBIDDEN_START;\n          break;\n\n        case NL_LIKE:\n          if (handler !== undefined) {\n            this.text += `${chunk.slice(start, this.prevI)}\\n`;\n          }\n\n          start = this.i;\n          forbiddenState = FORBIDDEN_START;\n          break;\n\n        case EOC:\n          if (handler !== undefined) {\n            this.text += chunk.slice(start);\n          } // eslint-disable-next-line no-labels\n\n\n          break scanLoop;\n\n        default:\n          forbiddenState = FORBIDDEN_START;\n      }\n    }\n\n    this.forbiddenState = forbiddenState;\n  }\n\n  handleTextOutsideRoot() {\n    // This is essentially a specialized version of captureTo which is optimized\n    // for a specialized task. We keep track of the presence of non-space\n    // characters in the text since these are errors when appearing outside the\n    // document root element.\n    let {\n      i: start\n    } = this;\n    const {\n      chunk,\n      textHandler: handler\n    } = this;\n    let nonSpace = false; // eslint-disable-next-line no-labels, no-restricted-syntax\n\n    outRootLoop: // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const code = this.getCode();\n\n      switch (code) {\n        case LESS:\n          {\n            this.state = S_OPEN_WAKA;\n\n            if (handler !== undefined) {\n              const {\n                text\n              } = this;\n              const slice = chunk.slice(start, this.prevI);\n\n              if (text.length !== 0) {\n                handler(text + slice);\n                this.text = \"\";\n              } else if (slice.length !== 0) {\n                handler(slice);\n              }\n            } // eslint-disable-next-line no-labels\n\n\n            break outRootLoop;\n          }\n\n        case AMP:\n          this.state = S_ENTITY;\n          this.entityReturnState = S_TEXT;\n\n          if (handler !== undefined) {\n            this.text += chunk.slice(start, this.prevI);\n          }\n\n          nonSpace = true; // eslint-disable-next-line no-labels\n\n          break outRootLoop;\n\n        case NL_LIKE:\n          if (handler !== undefined) {\n            this.text += `${chunk.slice(start, this.prevI)}\\n`;\n          }\n\n          start = this.i;\n          break;\n\n        case EOC:\n          if (handler !== undefined) {\n            this.text += chunk.slice(start);\n          } // eslint-disable-next-line no-labels\n\n\n          break outRootLoop;\n\n        default:\n          if (!isS(code)) {\n            nonSpace = true;\n          }\n\n      }\n    }\n\n    if (!nonSpace) {\n      return;\n    } // We use the reportedTextBeforeRoot and reportedTextAfterRoot flags\n    // to avoid reporting errors for every single character that is out of\n    // place.\n\n\n    if (!this.sawRoot && !this.reportedTextBeforeRoot) {\n      this.fail(\"text data outside of root node.\");\n      this.reportedTextBeforeRoot = true;\n    }\n\n    if (this.closedRoot && !this.reportedTextAfterRoot) {\n      this.fail(\"text data outside of root node.\");\n      this.reportedTextAfterRoot = true;\n    }\n  }\n\n  pushAttribNS(name, value) {\n    var _a;\n\n    const {\n      prefix,\n      local\n    } = this.qname(name);\n    const attr = {\n      name,\n      prefix,\n      local,\n      value\n    };\n    this.attribList.push(attr); // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n\n    if (prefix === \"xmlns\") {\n      const trimmed = value.trim();\n\n      if (this.currentXMLVersion === \"1.0\" && trimmed === \"\") {\n        this.fail(\"invalid attempt to undefine prefix in XML 1.0\");\n      }\n\n      this.topNS[local] = trimmed;\n      nsPairCheck(this, local, trimmed);\n    } else if (name === \"xmlns\") {\n      const trimmed = value.trim();\n      this.topNS[\"\"] = trimmed;\n      nsPairCheck(this, \"\", trimmed);\n    }\n  }\n\n  pushAttribPlain(name, value) {\n    var _a;\n\n    const attr = {\n      name,\n      value\n    };\n    this.attribList.push(attr); // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);\n  }\n  /**\n   * End parsing. This performs final well-formedness checks and resets the\n   * parser to a clean state.\n   *\n   * @returns this\n   */\n\n\n  end() {\n    var _a, _b;\n\n    if (!this.sawRoot) {\n      this.fail(\"document must contain a root element.\");\n    }\n\n    const {\n      tags\n    } = this;\n\n    while (tags.length > 0) {\n      const tag = tags.pop();\n      this.fail(`unclosed tag: ${tag.name}`);\n    }\n\n    if (this.state !== S_BEGIN && this.state !== S_TEXT) {\n      this.fail(\"unexpected end.\");\n    }\n\n    const {\n      text\n    } = this;\n\n    if (text.length !== 0) {\n      // eslint-disable-next-line no-unused-expressions\n      (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);\n      this.text = \"\";\n    }\n\n    this._closed = true; // eslint-disable-next-line no-unused-expressions\n\n    (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);\n\n    this._init();\n\n    return this;\n  }\n  /**\n   * Resolve a namespace prefix.\n   *\n   * @param prefix The prefix to resolve.\n   *\n   * @returns The namespace URI or ``undefined`` if the prefix is not defined.\n   */\n\n\n  resolve(prefix) {\n    var _a, _b;\n\n    let uri = this.topNS[prefix];\n\n    if (uri !== undefined) {\n      return uri;\n    }\n\n    const {\n      tags\n    } = this;\n\n    for (let index = tags.length - 1; index >= 0; index--) {\n      uri = tags[index].ns[prefix];\n\n      if (uri !== undefined) {\n        return uri;\n      }\n    }\n\n    uri = this.ns[prefix];\n\n    if (uri !== undefined) {\n      return uri;\n    }\n\n    return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);\n  }\n  /**\n   * Parse a qname into its prefix and local name parts.\n   *\n   * @param name The name to parse\n   *\n   * @returns\n   */\n\n\n  qname(name) {\n    // This is faster than using name.split(\":\").\n    const colon = name.indexOf(\":\");\n\n    if (colon === -1) {\n      return {\n        prefix: \"\",\n        local: name\n      };\n    }\n\n    const local = name.slice(colon + 1);\n    const prefix = name.slice(0, colon);\n\n    if (prefix === \"\" || local === \"\" || local.includes(\":\")) {\n      this.fail(`malformed name: ${name}.`);\n    }\n\n    return {\n      prefix,\n      local\n    };\n  }\n\n  processAttribsNS() {\n    var _a;\n\n    const {\n      attribList\n    } = this;\n    const tag = this.tag;\n    {\n      // add namespace info to tag\n      const {\n        prefix,\n        local\n      } = this.qname(tag.name);\n      tag.prefix = prefix;\n      tag.local = local;\n      const uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : \"\";\n\n      if (prefix !== \"\") {\n        if (prefix === \"xmlns\") {\n          this.fail(\"tags may not have \\\"xmlns\\\" as prefix.\");\n        }\n\n        if (uri === \"\") {\n          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n          tag.uri = prefix;\n        }\n      }\n    }\n\n    if (attribList.length === 0) {\n      return;\n    }\n\n    const {\n      attributes\n    } = tag;\n    const seen = new Set(); // Note: do not apply default ns to attributes:\n    //   http://www.w3.org/TR/REC-xml-names/#defaulting\n\n    for (const attr of attribList) {\n      const {\n        name,\n        prefix,\n        local\n      } = attr;\n      let uri;\n      let eqname;\n\n      if (prefix === \"\") {\n        uri = name === \"xmlns\" ? XMLNS_NAMESPACE : \"\";\n        eqname = name;\n      } else {\n        uri = this.resolve(prefix); // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n\n        if (uri === undefined) {\n          this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);\n          uri = prefix;\n        }\n\n        eqname = `{${uri}}${local}`;\n      }\n\n      if (seen.has(eqname)) {\n        this.fail(`duplicate attribute: ${eqname}.`);\n      }\n\n      seen.add(eqname);\n      attr.uri = uri;\n      attributes[name] = attr;\n    }\n\n    this.attribList = [];\n  }\n\n  processAttribsPlain() {\n    const {\n      attribList\n    } = this; // eslint-disable-next-line prefer-destructuring\n\n    const attributes = this.tag.attributes;\n\n    for (const {\n      name,\n      value\n    } of attribList) {\n      if (attributes[name] !== undefined) {\n        this.fail(`duplicate attribute: ${name}.`);\n      }\n\n      attributes[name] = value;\n    }\n\n    this.attribList = [];\n  }\n  /**\n   * Handle a complete open tag. This parser code calls this once it has seen\n   * the whole tag. This method checks for well-formeness and then emits\n   * ``onopentag``.\n   */\n\n\n  openTag() {\n    var _a;\n\n    this.processAttribs();\n    const {\n      tags\n    } = this;\n    const tag = this.tag;\n    tag.isSelfClosing = false; // There cannot be any pending text here due to the onopentagstart that was\n    // necessarily emitted before we get here. So we do not check text.\n    // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);\n    tags.push(tag);\n    this.state = S_TEXT;\n    this.name = \"\";\n  }\n  /**\n   * Handle a complete self-closing tag. This parser code calls this once it has\n   * seen the whole tag. This method checks for well-formeness and then emits\n   * ``onopentag`` and ``onclosetag``.\n   */\n\n\n  openSelfClosingTag() {\n    var _a, _b, _c;\n\n    this.processAttribs();\n    const {\n      tags\n    } = this;\n    const tag = this.tag;\n    tag.isSelfClosing = true; // There cannot be any pending text here due to the onopentagstart that was\n    // necessarily emitted before we get here. So we do not check text.\n    // eslint-disable-next-line no-unused-expressions\n\n    (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag); // eslint-disable-next-line no-unused-expressions\n\n    (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);\n    const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;\n\n    if (top === null) {\n      this.closedRoot = true;\n    }\n\n    this.state = S_TEXT;\n    this.name = \"\";\n  }\n  /**\n   * Handle a complete close tag. This parser code calls this once it has seen\n   * the whole tag. This method checks for well-formeness and then emits\n   * ``onclosetag``.\n   */\n\n\n  closeTag() {\n    const {\n      tags,\n      name\n    } = this; // Our state after this will be S_TEXT, no matter what, and we can clear\n    // tagName now.\n\n    this.state = S_TEXT;\n    this.name = \"\";\n\n    if (name === \"\") {\n      this.fail(\"weird empty close tag.\");\n      this.text += \"</>\";\n      return;\n    }\n\n    const handler = this.closeTagHandler;\n    let l = tags.length;\n\n    while (l-- > 0) {\n      const tag = this.tag = tags.pop();\n      this.topNS = tag.ns; // eslint-disable-next-line no-unused-expressions\n\n      handler === null || handler === void 0 ? void 0 : handler(tag);\n\n      if (tag.name === name) {\n        break;\n      }\n\n      this.fail(\"unexpected close tag.\");\n    }\n\n    if (l === 0) {\n      this.closedRoot = true;\n    } else if (l < 0) {\n      this.fail(`unmatched closing tag: ${name}.`);\n      this.text += `</${name}>`;\n    }\n  }\n  /**\n   * Resolves an entity. Makes any necessary well-formedness checks.\n   *\n   * @param entity The entity to resolve.\n   *\n   * @returns The parsed entity.\n   */\n\n\n  parseEntity(entity) {\n    // startsWith would be significantly slower for this test.\n    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n    if (entity[0] !== \"#\") {\n      const defined = this.ENTITIES[entity];\n\n      if (defined !== undefined) {\n        return defined;\n      }\n\n      this.fail(this.isName(entity) ? \"undefined entity.\" : \"disallowed character in entity name.\");\n      return `&${entity};`;\n    }\n\n    let num = NaN;\n\n    if (entity[1] === \"x\" && /^#x[0-9a-f]+$/i.test(entity)) {\n      num = parseInt(entity.slice(2), 16);\n    } else if (/^#[0-9]+$/.test(entity)) {\n      num = parseInt(entity.slice(1), 10);\n    } // The character reference is required to match the CHAR production.\n\n\n    if (!this.isChar(num)) {\n      this.fail(\"malformed character entity.\");\n      return `&${entity};`;\n    }\n\n    return String.fromCodePoint(num);\n  }\n\n}\n\nexports.SaxesParser = SaxesParser; //# sourceMappingURL=saxes.js.map","map":null,"metadata":{},"sourceType":"script"}