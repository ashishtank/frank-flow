"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeE2ELinting = exports.addCypressTsConfig = void 0;
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const dependencies_1 = require("../utility/dependencies");
const util_1 = require("../utility/util");
const path_1 = require("path");
function default_1(_options) {
    return (tree, _context) => {
        _options = Object.assign(Object.assign({}, _options), { __version__: util_1.getAngularVersion(tree) });
        return schematics_1.chain([
            updateDependencies(_options),
            _options.removeProtractor ? removeFiles() : schematics_1.noop(),
            addCypressFiles(),
            _options.addCypressTestScripts ? addCypressTestScriptsToPackageJson() : schematics_1.noop(),
            !_options.noBuilder ? modifyAngularJson(_options) : schematics_1.noop(),
        ])(tree, _context);
    };
}
exports.default = default_1;
function updateDependencies(options) {
    let removeDependencies;
    return (tree, context) => {
        context.logger.debug('Updating dependencies...');
        context.addTask(new tasks_1.NodePackageInstallTask());
        if (options.removeProtractor) {
            removeDependencies = rxjs_1.of('protractor').pipe(operators_1.map((packageName) => {
                context.logger.debug(`Removing ${packageName} dependency`);
                util_1.removePackageJsonDependency(tree, {
                    type: dependencies_1.NodeDependencyType.Dev,
                    name: packageName,
                });
                return tree;
            }));
        }
        const addDependencies = rxjs_1.of('cypress').pipe(operators_1.concatMap((packageName) => util_1.getLatestNodeVersion(packageName)), operators_1.map((packageFromRegistry) => {
            const { name, version } = packageFromRegistry;
            context.logger.debug(`Adding ${name}:${version} to ${dependencies_1.NodeDependencyType.Dev}`);
            dependencies_1.addPackageJsonDependency(tree, {
                type: dependencies_1.NodeDependencyType.Dev,
                name,
                version,
            });
            return tree;
        }));
        if (options.removeProtractor) {
            return rxjs_1.concat(removeDependencies, addDependencies);
        }
        return rxjs_1.concat(addDependencies);
    };
}
function addCypressTestScriptsToPackageJson() {
    return (tree, context) => {
        util_1.addPropertyToPackageJson(tree, context, 'scripts', {
            'cy:open': 'cypress open',
            'cy:run': 'cypress run',
        });
    };
}
function deleteDirectory(tree, path) {
    try {
        tree.delete(path);
    }
    catch (_a) { }
}
function removeFiles() {
    return (tree, context) => {
        if (tree.exists('./angular.json')) {
            const angularJsonValue = getAngularJsonValue(tree);
            const { projects } = angularJsonValue;
            // clean up projects generated by cli with versions <= 7
            Object.keys(projects)
                .filter((name) => name.endsWith('-e2e'))
                .forEach((projectName) => {
                const projectRoot = projects[projectName].root;
                deleteDirectory(tree, projectRoot);
                context.logger.debug(`Removing ${projectName} from angular.json projects`);
                delete angularJsonValue.projects[projectName];
            });
            // clean up projects generated by cli with versions > 7
            Object.keys(projects)
                .filter((name) => !name.endsWith('-e2e'))
                .forEach((projectName) => {
                const projectRoot = projects[projectName].root;
                deleteDirectory(tree, `${projectRoot}/e2e`);
            });
            return tree.overwrite('./angular.json', JSON.stringify(angularJsonValue, null, 2));
        }
        return tree;
    };
}
function addCypressFiles() {
    return (tree, context) => {
        context.logger.debug('Adding cypress files');
        const angularJsonValue = getAngularJsonValue(tree);
        const { projects } = angularJsonValue;
        return schematics_1.chain(Object.keys(projects).map((name) => {
            const project = projects[name];
            const projectPath = path_1.resolve(core_1.getSystemPath(core_1.normalize(project.root)));
            const workspacePath = path_1.resolve(core_1.getSystemPath(core_1.normalize('')));
            const relativeToWorkspace = path_1.relative(`${projectPath}/cypress`, workspacePath);
            const baseUrl = getBaseUrl(project);
            return schematics_1.mergeWith(schematics_1.apply(schematics_1.url('./files'), [
                schematics_1.move(project.root),
                schematics_1.template(Object.assign(Object.assign({}, core_1.strings), { root: project.root ? `${project.root}/` : project.root, baseUrl,
                    relativeToWorkspace })),
            ]));
        }))(tree, context);
    };
}
function getBaseUrl(project) {
    var _a, _b, _c, _d;
    let options = { protocol: 'http', port: 4200, host: 'localhost' };
    if ((_b = (_a = project.architect) === null || _a === void 0 ? void 0 : _a.serve) === null || _b === void 0 ? void 0 : _b.options) {
        const projectOptions = (_d = (_c = project.architect) === null || _c === void 0 ? void 0 : _c.serve) === null || _d === void 0 ? void 0 : _d.options;
        options = Object.assign(Object.assign({}, options), projectOptions);
        options.protocol = projectOptions.ssl ? 'https' : 'http';
    }
    return `${options.protocol}://${options.host}:${options.port}`;
}
function addNewCypressCommands(tree, angularJsonVal, project, runJson, openJson, removeProtractor) {
    const projectArchitectJson = angularJsonVal['projects'][project]['architect'];
    projectArchitectJson['cypress-run'] = runJson;
    projectArchitectJson['cypress-open'] = openJson;
    if (removeProtractor || !projectArchitectJson['e2e']) {
        projectArchitectJson['e2e'] = openJson;
    }
    return tree.overwrite('./angular.json', JSON.stringify(angularJsonVal, null, 2));
}
function getAngularJsonValue(tree) {
    const angularJsonAst = util_1.parseJsonAtPath(tree, './angular.json');
    return angularJsonAst.value;
}
function modifyAngularJson(options) {
    return (tree, context) => {
        if (tree.exists('./angular.json')) {
            const angularJsonVal = getAngularJsonValue(tree);
            const { projects } = angularJsonVal;
            if (!projects) {
                throw new schematics_1.SchematicsException('projects in angular.json is not defined');
            }
            Object.keys(projects).forEach((project) => {
                const cypressRunJson = {
                    builder: '@briebug/cypress-schematic:cypress',
                    options: {
                        devServerTarget: `${project}:serve`,
                    },
                    configurations: {
                        production: {
                            devServerTarget: `${project}:serve:production`,
                        },
                    },
                };
                const cypressOpenJson = {
                    builder: '@briebug/cypress-schematic:cypress',
                    options: {
                        devServerTarget: `${project}:serve`,
                        watch: true,
                        headless: false,
                    },
                    configurations: {
                        production: {
                            devServerTarget: `${project}:serve:production`,
                        },
                    },
                };
                const configFile = !!projects[project].root
                    ? `${projects[project].root}/cypress.json`
                    : null;
                if (configFile) {
                    Object.assign(cypressRunJson.options, { configFile });
                    Object.assign(cypressOpenJson.options, { configFile });
                }
                if (options.removeProtractor) {
                    context.logger.debug(`Replacing e2e command with cypress-run in angular.json`);
                    exports.removeE2ELinting(tree, angularJsonVal, project);
                }
                context.logger.debug(`Adding cypress/tsconfig.json to angular.json-tslint config`);
                exports.addCypressTsConfig(tree, angularJsonVal, project);
                context.logger.debug(`Adding cypress-run and cypress-open commands in angular.json`);
                addNewCypressCommands(tree, angularJsonVal, project, cypressRunJson, cypressOpenJson, options.removeProtractor);
            });
        }
        else {
            throw new schematics_1.SchematicsException('angular.json not found');
        }
        return tree;
    };
}
const addCypressTsConfig = (tree, angularJsonVal, projectName) => {
    var _a, _b, _c;
    const project = angularJsonVal.projects[projectName];
    let tsConfig = (_c = (_b = (_a = project === null || project === void 0 ? void 0 : project.architect) === null || _a === void 0 ? void 0 : _a.lint) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.tsConfig;
    if (tsConfig) {
        let prefix = '';
        if (project.root) {
            prefix = `${project.root}/`;
        }
        if (!Array.isArray(tsConfig)) {
            project.architect.lint.options.tsConfig = tsConfig = [tsConfig];
        }
        tsConfig.push(`${prefix}cypress/tsconfig.json`);
    }
    return tree.overwrite('./angular.json', JSON.stringify(angularJsonVal, null, 2));
};
exports.addCypressTsConfig = addCypressTsConfig;
const removeE2ELinting = (tree, angularJsonVal, project) => {
    var _a, _b, _c, _d, _e;
    const projectLintOptionsJson = (_c = (_b = (_a = angularJsonVal.projects[project]) === null || _a === void 0 ? void 0 : _a.architect) === null || _b === void 0 ? void 0 : _b.lint) === null || _c === void 0 ? void 0 : _c.options;
    if (projectLintOptionsJson) {
        let filteredTsConfigPaths;
        if (Array.isArray(projectLintOptionsJson['tsConfig'])) {
            filteredTsConfigPaths = (_d = projectLintOptionsJson === null || projectLintOptionsJson === void 0 ? void 0 : projectLintOptionsJson.tsConfig) === null || _d === void 0 ? void 0 : _d.filter((path) => {
                const pathIncludesE2e = path.includes('e2e');
                return !pathIncludesE2e && path;
            });
        }
        else {
            filteredTsConfigPaths = !((_e = projectLintOptionsJson === null || projectLintOptionsJson === void 0 ? void 0 : projectLintOptionsJson.tsConfig) === null || _e === void 0 ? void 0 : _e.includes('e2e'))
                ? projectLintOptionsJson === null || projectLintOptionsJson === void 0 ? void 0 : projectLintOptionsJson.tsConfig
                : '';
        }
        projectLintOptionsJson['tsConfig'] = filteredTsConfigPaths;
    }
    return tree.overwrite('./angular.json', JSON.stringify(angularJsonVal, null, 2));
};
exports.removeE2ELinting = removeE2ELinting;
//# sourceMappingURL=index.js.map